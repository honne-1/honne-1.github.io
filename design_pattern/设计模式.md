# 设计模式

## Introduction

### Design Tool

#### Domain Model

分析需求的过程

- 对外User
- 对内Programming

#### UML

- "-":private
- "+":public
- "*":protected
- class/object/abstract class(italic)/interface(第一部分空白)

### Code Smells

- Rigidity: too difficult to change even in simple ways
- Fragility: break in many places when a single change is made
- Immobility: hard to reuse
- Opacity: difficult to understand
- Needless Complexity
- Needless Repetition

### Good Design

- loose coupling high cohesion 低耦合 高内聚

### Design Principles

#### Principle of Least Knowledge / Law of Demeter

interact with as few classes as possible

#### Single  Responsiblility

尽量让每个类**只负责**软件中的**一个功能** 并将该功能**完全封装在该类中**

#### Open/Closed

**Open for extension. Close for modification**

**实现新功能**时尽可能保持**已有代码不变**

#### Liskov Substitution Principle

well-designed inheritance

**subtypes must be substitutable for their base types**

use **more delegation(delegate functionality to others) and composition(reuse behaviour)** instead of inheritance

## Design Patterns

### Creational 创建型模式

创建型可以理解为**生成新的对象**

#### 简单工厂 vs 工厂 vs 抽象工厂

- 简单工厂
    - 生产一种产品
    - 需要**新增其他种类产品时需要修改工厂实例的代码**（违背开闭原则）
- 工厂
    - **不同的工厂生产不同的产品**，一个工厂生产一种产品
    - 需要**新增其他种类产品时需要实例对应的工厂**，产品过多的话工厂数量暴增，不增加复杂度，难以维护和理解
- 抽象工厂
    - **生产一个集合的产品**，生产出来的每个集合代表集合不同的态（例如上等品、中等品、次品）
    - 如果**新增不同等级的集合产品只需要再实现一个工厂类实例**，则符合开闭原则
    - 如果是需要在这个**集合内加入新的产品，需要修改工厂类的接口**，则不符合开闭原则

#### Simple Factory 简单工厂

- 定义一个类**创建其他类实例**
- 根据**参数不同返回不同实例**
- **被创建实例**通常具有**共同父类**
- **对象的创建和使用分离**
- 不够灵活 **新增产品需要修改工厂类**

<img src="/Users/honne/Desktop/notes/design_pattern/asset/simple_factory_uml.png" alt="simple_factory_uml" style="zoom: 33%;" />

```java
abstract class Product{
    public void use() {

    }
}

class ProductA extends Product {
    public void use(){
        System.out.println("使用了产品A");
    }
}

class ProductB extends Product {
    public void use(){
        System.out.println("使用了产品B");
    }
}

class Factory{

    public static Product createProduct(String type){
        if("A".equals(type)){
            return new ProductA();
        } else if("B".equals(type)){
            return new ProductB();
        }
        return new ProductA();
    }
}
```

#### Factory Method 工厂

Define an **interface for creating an object**, but **let subclasses decide which class to instantiate**

FactoryMethod **lets a class defer instantiation to subclasses**

![factory_method_uml](/Users/honne/Desktop/notes/design_pattern/asset/factory_method_uml.png)

```java
public class Factory {
    public static void main(String[] args) {
        FactoryA factoryA = new FactoryA();
        factoryA.createProduct().print();
        FactoryB factoryB = new FactoryB();
        factoryB.createProduct().print();
    }
}
interface AbstractFactory{
    public Product createProduct();
}

class FactoryA implements AbstractFactory{
    @Override
    public Product createProduct(){
        return new ProductA();
    }
}
class FactoryB implements AbstractFactory{
    @Override
    public  Product createProduct(){
        return new ProductB();
    }
}

abstract class Product {
    public abstract void print();
}
class ProductA extends Product {
    @Override
    public void print(){
        System.out.println("ProductA正在打印！");
    }
}
class ProductB extends Product {
    @Override
    public void print(){
        System.out.println("ProductB正在打印！");
    }
}
```

#### Abstract Factory 抽象工厂

![abstract_factory_uml](/Users/honne/Desktop/notes/design_pattern/asset/abstract_factory_uml.png)

```java
interface Phone {}
class iPhone implements Phone {}
class HuaWei implements Phone {}

interface Mask {}
class N95 implements Mask {}
class KN90 implements Mask {}

interface AbstractFactory {
  Phone createPhone(String arg);
  Mask createMask(String arg);
}

class FactoryA implements AbstractFactory {
  @Override
    public Phone createPhone(String arg){
        return new iPhone();
    }
  @Override
    public Mask createMask(String arg){
        return new N95();
    }
}

class FactoryB implements AbstractFactory {
  @Override
    public Phone createPhone(String arg){
        return new HuaWei();
    }
  @Override
    public Mask createMask(String arg){
        return new KN90();
    }
}
```

#### Builder 生成器/建造者

**分步骤创建对象** 将构造对象的步骤抽取出来放入builder类中

```java
House house = new House.Builder().setDoor(new Door()).setWall(new Wall()).build();
  
// lombok.Builder 注解也行
class House{
  private Window window;
  private Door door;
  private Wall wall;
  
  public House(Builder builder) {
    this.window = builder.window;
    this.door = builder.door;
    this.wall = builder.wall;
  }
  
  static final class Builder {
    private Window window;
    private Door door;
    private Wall wall;
    
    public Builder setWindow(Window window) {
      this.window = window;
      return this;
    }
    
    public Builder setDoor(Door door) {
      this.door = door;
      return this;
    }
    
    public Builder setWall(Wall wall) {
      this.wall = wall;
      return this;
    }
    
    public House build() {
      return new House(this);
    }
  }
}
```

#### Prototype 原型

在外部无法获取对象的私有变量/属性时用原型模式可以让**被复制(克隆)对象自己负责复制/克隆的工作以及提供复制/克隆体**

```java
Plane plane = new Plane();
Plane clone = (Plane) plane.clone();

interface Prototype{
  Object clone();
}
@Getter
class Plane implements Prototype{
  private String name;
  private String type;
  
  public Plane(){
    name = "name" + Math.random();
    type = "type" + Math.random();
  }
  
  // 将原型对象传进去 通过构造器访问原型对象的属性 
  // 一个类的内部可以访问对象的私有成员
  public Plane(Plane plane) {
    this.name = name;
    this.type = type;
  }
  
  @Override
  public Object clone() {
    return new Plane(this);
  }
  
}


```



#### Singleton 单例

**Ensure a class has only one instance and provide a global point of access to it**

- 私有构造 阻止类被常规方法实例化
- 静态方法/枚举返回实例 保证实例唯一性
- 保证在创建实例时线程安全
- 确保反序列化时不会重新创建对象

##### 饿汉

```java
// 线程安全
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }

}
```

##### 懒汉

```java
// 线程不安全
public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance(){
        if (instance == null) {
          instance = new Singleton();
        }
      return instance;
    }
}
```

##### 双重锁懒汉 (Double-Checked Locking)

```java
// 线程安全
public class Singleton {
		// volatile 避免指令重排
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance(){
        if (instance == null) {
          synchronized (Singleton.class){
            if (instance == null) {
              // 1.分配内存 -> 2.初始化对象 -> 3.指向刚分配的地址
              // 发生指令重排 如果线程A执行1和3但没执行2时 线程B判断null时直接返回还没初始化的instance
              instance = new Singleton();
            }
          }
        }
      return instance;
    }
}
```

##### 静态内部类

```java
public class Singleton {

    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }

    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

}
```

##### 枚举模式

```java
public enum Singleton {

    INSTANCE;
    public void test(){
        System.out.println("hi~");
    }

}
```

##### CAS

```java
public class Singleton {

    private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>();

    private static Singleton instance;

    private Singleton() {
    }

    public static final Singleton getInstance() {
        for (; ; ) {
          	if (instance == null) {
              INSTANCE.compareAndSet(null, new Singleton());
            }
            return INSTANCE.get();
        }
    }

}
```

##### 多个实例

- **分布式系统中多个JVM** 各JVM都有一个实例
- 同一个JVM虚拟机使用**多个类加载器同时加载这个类**产生多个实例

### Structural 结构型模式

结构型可以理解为通过某种方式**构建更大的类或类对象**

#### Adapter 适配器

**Convert the interface of a class into another interface clients expect**

Adapter **lets classes work together** that couldn't otherwise because of **incompatible interfaces.**

```java
// return new Adapter(new ChineseSpeaker()).translate();

class ChineseSpeaker {
  public String speak() {
    return "你好";
  }
}

interface Translator {
  public String translate();
}

class Adapter implements Translator {
  // 关联使用(也可以用继承)
  private ChineseSpeaker chineseSpeaker;
  public Adapter (ChineseSpeaker speaker){
    this.chineseSpeaker = speaker;
  }
  @Override
  public String translate() {
    String res = chineseSpeaker.speak();
    res = "hello";
    return res;
  }
}
```

#### Bridge 桥接

**将抽象和实现解耦使得两者可以独立变化**

![bridge](/Users/honne/Desktop/notes/design_pattern/asset/bridge.svg)

```java
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}

// 桥接实现接口
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}

// 桥接实现类
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}

// 抽象类包含桥接接口
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();  
}

// 实体类
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```



#### Composite 组合

```java
interface Goal {
    public boolean pass();
}

abstract class GoalLeaf implements Goal {
     protected String type;
    protected MapGenerator map;

    public GoalLeaf(String type, MapGenerator map) {
        this.type = type;
        this.map = map;
    }
    @Override
    public abstract boolean pass();
}

class GoalLeafBoulders extends GoalLeaf {
  	public GoalLeafBoulders(String type, MapGenerator map) {
        super(type, map);
    }
  
    @Override
    public boolean pass() {
        for (Entity e : map.getEntities()) {
            if (e instanceof FloorSwitch) {
                FloorSwitch switch1 = (FloorSwitch) e;
                if (switch1.isActive() == false) {
                    return false;
                }
            }
        }
        return true;
    }
}

public class GoalLeafEnemies extends GoalLeaf {
  	public GoalLeafBoulders(String type, MapGenerator map) {
        super(type, map);
    }
    @Override
    public boolean pass() {
        return map.getEnemyList().size() == 0;
    }
}

public class GoalLeafExit extends GoalLeaf {
  	public GoalLeafBoulders(String type, MapGenerator map) {
        super(type, map);
    }
  
    @Override
    public boolean pass() {
        for (Entity e : map.getEntities()) {
            if (e instanceof Exit) {
                if (!e.getPosition().equals(map.getPlayer().getPosition())) {
                    return false;
                }
            }
        }
        return true;
    }
}

public class GoalLeafTreasure extends GoalLeaf {
  	public GoalLeafBoulders(String type, MapGenerator map) {
        super(type, map);
    }
  
    @Override
    public boolean pass() {
        for (Entity e : map.getEntities()) {
            if (e instanceof Treasure || e instanceof SunStone) {
                return false;
            }
        }
        return true;

    }

}

class GoalComposite implements Goal {
    private List<Goal> goals = new ArrayList<>();
    private List<Goal> returngoals = new ArrayList<>();

    @Override
    public boolean pass() {
        int num = 0;
        for (Goal goal : goals) {
            if (goal.pass()) {
                num++;
                returngoals.remove(goal);
            }
        }
        if (this.logic.equals("AND")) {
            return num == goals.size();
        } else {
            return num >= 1;
        }
    }
}
```



#### Decorator 装饰

- **在原有类的基础上动态地添加新的功能**
- **在对象层面实现功能扩展**，而不是继承的类层面
- **比继承更加灵活**

<img src="/Users/honne/Desktop/notes/design_pattern/asset/decorator_uml.png" alt="decorator_uml" style="zoom: 25%;" />

```java
// new RobotDecorator(new FirstRobot()).doOtherThing;

interface Robot {
  void doSth();
}

class FirstRobot implements Robot {
  @Override
  public void doSth() {
    System.out.println("robot 1.0");
  }
}

abstract class RobotDecorator implements Robot {
  private Robot robot;
  public RobotDecorator(Robot robot) {
    this.robot = robot;
  }
  @Override
  public void doSth() {
    robot.doSth();
  }
  
  public void doOtherThing() {
    // 可以有原来的版本
    // robot.doSth();
    
    // 可以有新的版本
    System.out.println("robot 2.0");
  }
}

class ConcreteRobotDecorator extends RobotDecorator {
  ...
}
```

#### Facade 外观/门面

- Provide a unified interface to a set of interfaces in a subsystem
- Facade defines a higher-level interface that makes the subsystem easier to use
- **子系统外部和内部通信**通过一个**统一的对象**进行 外观模式**提供高层次类**方便使用子系统
- **不符合开闭原则**：子系统内部拓展时必须要修改外观模式类

```java
new Facade().prove();

class Subsystem1{
  boolean method1() {return true;}
}

class Subsystem2{
  boolean method2() {return true;}
}

class Subsystem3{
  boolean method3() {return true;}
}

class Facade {
  Subsystem1 s1 = new Subsystem1();
  Subsystem2 s2 = new Subsystem3();
  Subsystem1 s3 = new Subsystem3();
  
  boolean prove() {return s1.method1() && s2.method2() && s3.method3();}
}
```

#### Flyweight 享元

- 运用**共享技术**有效的支持**大量细类度的对象**
- **池技术**
- **将资源进行有效复用** 避免重复对象创建

```java
BikeFlyWeight bike1 = BikeFlyWeightFactory.getInstance.getBike();
BikeFlyWeight bike2 = BikeFlyWeightFactory.getInstance.getBike();

bike1.rideBike("zhang san");
bike2.rideBike("zhao si");
bike2.returnBike();

BikeFlyWeight bike3 = BikeFlyWeightFactory.getInstance.getBike();
bike3.rideBike("wang wu");
bike3.returnBike();



// 享元抽象类
abstract class BikeFlyWeight{
  // 内部状态
  protected Integer state = 0;
  
  // 外部状态(userName)
  abstract void rideBike(String userName);
  abstract void returnBike();
  
  public Integer getState(){
    return false;
  }
}

// 享元类
class MoBikeFlyWeight extends BikeFlyWeight{
  // 新内部状态
  private String bikeID;
  
  public MoBikeFlyWeight(String bikeID){
    this.bikeID = bikeID;
  }
  
  @Override
  void rideBike(String userName){
    state = 1;
    // do sth
  }
  void returnBike(){
    state = 0;
  }
}

// 享元工厂(池)
class BikeFlyWeightFactory{
  // 饿汉
  private static BikeFlyWeightFactory instance = new BikeFlyWeightFactory();
  private Set<BikeFlyWeight> pool = new HashSet<>();
  
  public static BikeFlyWeightFactory getInstance(){
    return instance;
  }
  
  private BikeFlyWeightFactory(){
    for(int i = 0; i < 2; i++) {
      pool.add(new MoBikeFlyWeight(i + " number"));
    }
  }
  
  public BikeFlyWeight getBike(){
    for (BikeFlyWeight bike : pool) {
      if (bike.getState() == 0) return bike;
    }
    return null;
  }
}
```

#### Proxy 代理

- **为其他对象提供一种代理以控制对这个对象的访问**(**只能通过代理访问实际目标**)
- 远程调用：接口在客户端 逻辑实现类在服务端 代理模式使**客户端拥有代理类 远程调用服务端实现类 将结果返回到客户端**

```java
new RealSubjectProxy().doWork();

interface Subject{
  void doWork();
}

class RealSubject implements Subject{
  @Override
  public void doWork(){
    
  }
}

class RealSubjectProxy implements Subject{
  private RealSubject subject;
  // 可以传参
  public RealSubjectProxy(RealSubject subject){
    this.subject = subject;
  }
  
  // 可以不传参
  public RealSubjectProxy(){
    try {
      this.subject = (RealSubject) this.getClass().getClassLoader().loadClass("xxx.RealSubject").newInstance();
    } catch (Exception e) {
      ...
    }

  }
  
  public void connect(){
    System.out.println("connecting");
  }
  
  public void log(){
    System.out.println("logging");
  }
  
  @Override
  public void doWork(){
    connect();
    subject.doWork();
    log();
  }
}
```

### Behavioral 行为模式

#### Chain of Responsibility 责任链

- 处理请求 使多个处理器都有机会处理该请求直到某个处理成功为止
- **将多个处理器串成链 把请求在链上传递**
- 将请求和处理分开 **请求者和处理者解耦合** 提高系统灵活性
- 链长时降低系统性能

```java
Handler firstLevel = new Leader();
Handler lastLevel = new Boss();

firstLevel.setNextHandler(lastLevel);

firstLevel.process(10);
firstLevel.process(20);

abstract class Handler{
  protected Handler nextHandler;
  
  public void setNextHandler(Handler nextHandler) {
    this.nextHandler = nextHandler;
  }
  
  public abstract void process(Integer info);
}

class Leader extends Handler{
  @Override
  public void process(Integer info){
    if (info > 0 && info < 11) {
      System.out.println("Leader handling");
    } else {
      nextHandler.process(info);
    }
  }
}

class Boss extends Handler{
  @Override
  public void process(Integer info){
    System.out.println("Boss handling");
  }
}
```

#### Command 命令

命令模式**将请求转换为一个包含与请求相关的所有信息的独立对象** 

这种转换可以根据不同请求**将方法参数化/延迟请求执行/将其放入队列中 且能实现撤销**操作

```java
Button button = new Button();
TextBox box = new TextBox();

PrintCommand printCommand = new PrintCommand(box);
button.bindCommand(printCommand);

box.setContext("ABC");
button.doPrint();

box.setContext("ABCD");
button.doPrint();

// GUI层 按钮
class Button{
  private Command command;
  
  public void bindCommand(Command command) {
    this.command = command;
  }
  
  public void doPrint() {
    if (command == null) throw new RuntimeException("init failure");
    command.execute();
  }
}

// 业务逻辑层 打印服务
class PrintSerice{
  public void print(String text) {
    System.out.println(text);
  }
}

interface Command{
  void execute();
}

@Data
class TextBox{
  private String context;
}

class PrintCommand implements Command{
  private PrintSerice serviceProvider = new PrintSerice();
  private TextBox box;
  
  public PrintCommand(TextBox box) {
    this.box = box;
  }
  
  @Override
  public void execute(){
    serviceProvider.print(box.getContext());
  }
}
```

#### Iterator 迭代器

在**不暴露集合底层表现形式**(列表/栈/树等)的情况下**遍历集合中所有的元素**

![iterator_1](/Users/honne/Desktop/notes/design_pattern/asset/iterator_1.png)

<img src="/Users/honne/Desktop/notes/design_pattern/asset/iterator_3.png" alt="iterator_3" style="zoom:50%;" />

<img src="/Users/honne/Desktop/notes/design_pattern/asset/iterator_2.png" alt="iterator_2" style="zoom:50%;" />

#### Mediator 中介者

中介者**减少对象之间混乱无序的依赖关系**且**限制对象间的直接交互** 使**所有对象通过一个中介者对象进行沟通**

```java
public class MediatorPatternDemo {
   public static void main(String[] args) {
     	Mediator mediator = new Mediator();
      User robert = new User(mediator, "Robert");
      User john = new User(mediator, "John");
 
      robert.sendMessage("Hi! John!");
      john.sendMessage("Hello! Robert!");
   }
}

// 对象
public class User {
   private String name;
   Mediator mediator; // 使用中介者
  
   public User(Mediator mediator, String name) {
     this.mediator = mediator;
     this.name = name;
   }
 
   public String getName() {
      return name;
   }
 
   public void setName(String name) {
      this.name = name;
   }
 
   public void sendMessage(String message){
      Mediator.showMessage(this, message);
   }
}

// 中介者
public class Mediator {
   public static void showMessage(User user, String message){
      System.out.println(new Date().toString()
         + " [" + user.getName() +"] : " + message);
   }
}
```

#### Observer 观察者

- **定义对象间的一对多依赖关系** 当对象**状态发生改变时其相关依赖对象都会得到通知**并自动随之更新
- 没有解耦合 **观察者和被观察者相互知道**

```java
Debit zhangSan = new Observer();
zhangSan.borrow(new Observee1());
zhangSan.borrow(new Observee2());
zhangSan.setMoneyAvailable(1);
zhangSan.notifyObservee();

interface Debit{
  void borrow(Observee observee);
  void notifyObservee;
}

class Observer implements Debit{
  private List<Observee> observeeList = new ArrayList<>();
  private Integer moneyAvailable = 0;
  
  @Override
  public void borrow(Observee observee){
    observeeList.add(observee);
  }
  
  @Override
  public void notifyObservee() {
    observeeList.forEach(observee -> observee.takeMoney());
  }
  
}

interface Observee{
  void takeMoney();
}

class Observee1 implements Observee1 {
  public void takeMoney() {
    System.out.println("Observee1 takes the money");
  }
}

class Observee2 implements Observee1 {
  public void takeMoney() {
    System.out.println("Observee2 takes the money");
  }
}
```

#### State vs Strategy

| State                                                        | Strategy                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **根据状态来决定行为**，不同状态之下会采取一系列不同的行为   | **没有状态的概念**，直接关注于行为的实现方案                 |
| **所有的方法的实现都可能发生变化**                           | **某一个行为的具体执行过程**                                 |
| e.g. 今天状态“不开心” 起床/吃饭/读书等一系列行为都会受到影响 | e.g. 读书怎么读：站着坐着还是躺着？                          |
| 业务流程是一个**不同状态的有限组合或排列方式**               | 某一个业务**根据场景不同可以有多种实现方式**<br />业务流程中的某一个环节根据场景不同有多种实现方式 |

#### State 状态

- 允许一个对象(状态对象) 在其**内部状态改变时变更其行为** 对象看起来似乎修改了自己的类 实际只是**不同状态关联不同的行为**
- **封装了转换规则 枚举可能状态** 所有与某个状态有关的行为都放入到状态类中 方便添加新的状态
- **多个环境对象可共享一个状态对象** 减少系统对象数量
- 系统/状态类和状态对象个数增多 使用不当可能会导致代码结构混乱

```java
Context context = new Context();
context.changeState(new Happy());
context.doSomething();
context.changeState(new Sad());
context.doSomething();
context.changeState(new Angry());
context.doSomething();

abstract class State{
  abstract void doWork();
}

class Happy extends State{
  @Override
  void doWork() {
    System.out.println("Happy");
  }
}

class Sad extends State{
  @Override
  void doWork() {
    System.out.println("Sad");
  }
}

class Angry extends State{
  @Override
  void doWork() {
    System.out.println("Angry");
  }
}

class Context{
  private State state;
  public void changeState(State state){
    this.state = state;
  }
  public void doSomething(){
    state.doWork();
  }
}
```

#### Strategy 策略

Define **a family of algorithms**, **encapsulate** each one and **make them interchangeable**

**定义一组算法 每个算法都封装起来且算法间互相可转换**

```java
Context context = new Context(new Happy());
context.executeStrategy();
context = new Context(new Sad());
context.executeStrategy();
context = new Context(new Angry());
context.executeStrategy();

interface Strategy{
  void doWork();
}

class Happy implements Strategy{
  @Override
  void doWork() {
    System.out.println("Happy");
  }
}

class Sad implements Strategy{
  @Override
  void doWork() {
    System.out.println("Sad");
  }
}

class Angry implements Strategy{
  @Override
  void doWork() {
    System.out.println("Angry");
  }
}

class Context{
  private Strategy strategy;
  
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public void executeStrategy(){
      strategy.doWork();
   }
}
```

##### 订单场景

![strategy_scene](/Users/honne/Desktop/notes/design_pattern/asset/strategy_scene.png)

###### 策略接口定义

通常包含两个方法：**获取策略类型的方法和处理策略业务逻辑的方法**

```java
/**
 * 第三方支付
 */
public interface Payment {

    /**
     * 获取支付方式
     * 
     * @return 响应，支付方式
     */
    PayTypeEnum getPayType();

    /**
     * 支付调用
     * 
     * @param order 订单信息
     * @return 响应，支付结果
     */
    PayResult pay(Order order);

}
```

###### 策略接口实现

每种支付类都实现了上述接口（基于接口而非实现编程），这样我们可以**灵活的替换不同的支付方式**

```java
/**
 * 微信支付
 */
@Component
public class WxPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.WX;
    }

    @Override
    public PayResult pay(Order order) {
        调用微信支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
/**
 * 支付宝支付
 */
@Component
public class AlipayPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.ALIPAY;
    }

    @Override
    public PayResult pay(Order order) {
        调用支付宝支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
/**
 * 银行卡支付
 */
@Component
public class BankCardPayment implements Payment {

    @Override
    public PayTypeEnum getPayType() {
        return PayTypeEnum.BANK_CARD;
    }

    @Override
    public PayResult pay(Order order) {
        调用银行卡支付
        if (成功) {
            return PayResult.SUCCESS;
        } else {
            return PayResult.FAIL;
        }
    }

}
```

###### 创建策略

策略模式包含一组同类的策略，在使用时通常通过类型来判断创建哪种策略来进行使用

**可使用工厂模式来创建策略，以屏蔽策略的创建细节**

以下两种创建方式为无状态的，即**不包含成员变量，它们可以被共享使用**

```java
public class PaymentFactory {
    private static final Map<PayTypeEnum, Payment> payStrategies = new HashMap<>();

    static {
        payStrategies.put(PayTypeEnum.WX, new WxPayment());
        payStrategies.put(PayTypeEnum.ALIPAY, new AlipayPayment());
        payStrategies.put(PayTypeEnum.BANK_CARD, new BankCardPayment());
    }

    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (!payStrategies.containsKey(payType)) {
            throw new IllegalArgumentException("pay type not supported.");
        }
        return payStrategies.get(payType);
    }

}
```

或者使用 `Spring` 创建：

```java
@Component
public class PaymentFactory implements InitializingBean, ApplicationContextAware {
    private static final Map<PayTypeEnum, Payment> payStrategies = new HashMap<>();

    private ApplicationContext appContext;

    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (!payStrategies.containsKey(payType)) {
            throw new IllegalArgumentException("pay type not supported.");
        }
        return payStrategies.get(payType);
    }

    @Override
    public void setApplicationContext(@NonNull ApplicationContext applicationContext) {
        appContext = applicationContext;
    }

    @Override
    public void afterPropertiesSet() {
        // 将 Spring 容器中所有的 Payment 接口实现类注册到 payStrategies
        appContext.getBeansOfType(Payment.class)
                  .values()
                  .forEach(payment -> payStrategies.put(payment.getPayType(), payment));
    }
}
```

如果**策略类是有状态的，需要根据业务场景每次创建新的策略对象**

可以在**工厂方法中，每次生成新的策略对象**，而不是使用已经提前缓存好的策略对象

```java
public class PaymentFactory {
    public static Payment getPayment(PayTypeEnum payType) {
        if (payType == null) {
            throw new IllegalArgumentException("pay type is empty.");
        }
        if (payType == PayTypeEnum.WX) {
            return new WxPayment();
        }
        if (payType == PayTypeEnum.ALIPAY) {
            return new AlipayPayment();
        }
        if (payType == PayTypeEnum.BANK_CARD) {
            return new BankCardPayment();
        }
        throw new IllegalArgumentException("pay type not supported.");
    }

}
```

###### 使用策略

通常我们事先并不知道会使用哪个策略，在程序运行时根据配置、用户输入、计算结果等来决定到底使用哪种策略

需根据用户的选择来决定使用哪种支付方式

```java
Order order = 订单信息
PayResult payResult = PaymentFactory.getPayment(payType).pay(order);
if (payResult == PayResult.SUCCESS) {
    System.out.println("支付成功");
} else if (payType == 支付宝) {
    System.out.println("支付失败");
}
```

#### Template Method 模版方法

定义一个操作中算法的框架 将一些步骤**延迟到子类中** 使子类可以在**不改变算法结构的情况下重定义算法的某些特定步骤**

```java
Cooking cooking = new CookingFood();
cooking.cook();

abstract class Cooking{
  protected abstract void step1();
  protected abstract void step2();
  public void cook(){
    System.out.println("Template start");
    step1();
    step2();
    System.out.println("Template end");
  }
}

class CookingFood extends Cooking{
  @Override
  protected void step1(){
    System.out.println("放鸡蛋");
  }
  
  @Override
  protected void step2(){
    System.out.println("放盐");
  }
}
```

#### Visitor 访问者

**封装一些作用于某种数据结构中各元素的操作** 在**不改变数据结构**的前提下**定义作用于这些元素的新操作**

![visitor](/Users/honne/Desktop/notes/design_pattern/asset/visitor.jpeg)

```java
public class VisitorPatternDemo {
   public static void main(String[] args) {
 
      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   }
}

// 表示元素的接口
public interface ComputerPart {
   public void accept(ComputerPartVisitor computerPartVisitor);
}

// 元素实体类
public class Keyboard implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Monitor implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Mouse implements ComputerPart {
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      computerPartVisitor.visit(this);
   }
}

public class Computer implements ComputerPart {
   
   ComputerPart[] parts;
 
   public Computer(){
      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};      
   } 
 
 
   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) {
      for (int i = 0; i < parts.length; i++) {
         parts[i].accept(computerPartVisitor);
      }
      computerPartVisitor.visit(this);
   }
}

// 访问者接口
public interface ComputerPartVisitor {
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
}

// 实体访问者
public class ComputerPartDisplayVisitor implements ComputerPartVisitor {
 
   @Override
   public void visit(Computer computer) {
      System.out.println("Displaying Computer.");
   }
 
   @Override
   public void visit(Mouse mouse) {
      System.out.println("Displaying Mouse.");
   }
 
   @Override
   public void visit(Keyboard keyboard) {
      System.out.println("Displaying Keyboard.");
   }
 
   @Override
   public void visit(Monitor monitor) {
      System.out.println("Displaying Monitor.");
   }
}
```



















